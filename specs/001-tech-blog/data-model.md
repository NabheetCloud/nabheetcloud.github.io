# Data Model: Tech Learnings Blog

**Feature**: Tech Learnings Blog  
**Branch**: 001-tech-blog  
**Date**: 2025-11-05  
**Purpose**: Define entity schemas, relationships, validation rules, and state management for the static blog

## Overview

This data model defines the structure of content entities for a static blog generated by Eleventy. Since this is a static site (no database), entities are represented as:

1. **Markdown Files with YAML Frontmatter** (Blog Post, Tag metadata)
2. **Nunjucks Data Files** (Author Profile)
3. **Browser LocalStorage** (Theme Preference)
4. **Build-Time Collections** (Generated by Eleventy from Markdown files)

All entities are validated at build time. Invalid frontmatter causes build failures (fail-fast principle).

---

## Entity Schemas

### 1. Blog Post

**Representation**: Markdown file with YAML frontmatter in `src/posts/`

**Purpose**: Represents a published article with title, content, metadata, and taxonomy

**Frontmatter Schema**:

```yaml
---
title: string                    # REQUIRED: Post title (used in <h1>, <title>, OpenGraph)
slug: string                     # OPTIONAL: URL-friendly identifier (auto-generated from title if omitted)
date: YYYY-MM-DD                 # REQUIRED: Publication date (ISO 8601 format)
updated: YYYY-MM-DD              # OPTIONAL: Last updated date (for revised articles)
author: string                   # REQUIRED: Author name (must match author in _data/author.json)
excerpt: string                  # OPTIONAL: Custom excerpt (defaults to first 150 chars of content)
tags: array<string>              # REQUIRED: Array of tag slugs (e.g., ["ai", "system-design"])
featured_image: string           # OPTIONAL: Path to featured image (used in OpenGraph, post header)
featured_image_alt: string       # REQUIRED if featured_image present: Alt text for accessibility
draft: boolean                   # OPTIONAL: If true, post excluded from production builds (default: false)
permalink: string                # OPTIONAL: Custom permalink (default: /posts/{{ slug }}/)
layout: string                   # OPTIONAL: Template layout (default: "layouts/post.njk")
---

# Post Content (Markdown)

Your article content here with **Markdown** formatting, code blocks, images, etc.
```

**Field Descriptions**:

| Field | Type | Required | Validation | Default |
|-------|------|----------|------------|---------|
| `title` | string | Yes | 1-100 chars, no special chars (<, >, ", ') | N/A |
| `slug` | string | No | Lowercase, hyphens only, no spaces | Auto-generated from title |
| `date` | date | Yes | ISO 8601 (YYYY-MM-DD), not future-dated | N/A |
| `updated` | date | No | ISO 8601 (YYYY-MM-DD), >= date | N/A |
| `author` | string | Yes | Must match author.name in _data/author.json | N/A |
| `excerpt` | string | No | 100-300 chars recommended | First 150 chars of content |
| `tags` | array | Yes | 1-5 tags, each matching tag slug in _data/tags.json | N/A |
| `featured_image` | string | No | Valid relative path in src/assets/images/ | N/A |
| `featured_image_alt` | string | Conditional | Required if featured_image present, 10-150 chars | N/A |
| `draft` | boolean | No | true or false | false |
| `permalink` | string | No | Must start with `/`, end with `/` | `/posts/{{ slug }}/` |
| `layout` | string | No | Valid layout path in _includes/layouts/ | `layouts/post.njk` |

**Content Body (Markdown)**:
- Markdown content following frontmatter (after `---` closing delimiter)
- Standard Markdown syntax: headings, paragraphs, lists, blockquotes, links, images, code blocks
- Code blocks support language specification for Prism.js syntax highlighting (e.g., ` ```javascript`)
- Images referenced as relative paths (e.g., `![Alt text](./images/diagram.png)`)

**File Naming Convention**:
- Format: `YYYY-MM-DD-slug.md` (e.g., `2025-11-05-building-saleor-app.md`)
- Date in filename should match `date` in frontmatter (validated at build time)
- Slug in filename should match `slug` in frontmatter (or auto-generated slug from title)

**Example**:

```yaml
---
title: "Building a Saleor Commerce App with GraphQL"
slug: "building-saleor-app"
date: 2025-11-01
author: "Nabheet Madan"
excerpt: "Learn how to build a custom Saleor app using GraphQL subscriptions and webhooks for real-time inventory management."
tags: ["saleor", "graphql", "ecommerce"]
featured_image: "/assets/images/posts/saleor-architecture.jpg"
featured_image_alt: "Saleor app architecture diagram showing GraphQL API and webhook flows"
draft: false
---

# Building a Saleor Commerce App

In this deep dive, we'll explore how to build a custom Saleor app that listens to inventory changes...
```

**Relationships**:
- **Blog Post → Tags**: Many-to-many (post has multiple tags, tag appears on multiple posts)
- **Blog Post → Author**: Many-to-one (post has one author, author writes multiple posts)

**Computed Fields** (generated at build time by Eleventy):
- `reading_time`: Calculated from word count (avg 200 words/min)
- `url`: Full URL path based on permalink
- `related_posts`: Array of 3-5 posts with overlapping tags (sorted by tag match count, then date)
- `year`: Year extracted from date (for archive grouping)
- `formatted_date`: Human-readable date (e.g., "November 1, 2025")

**Validation Rules**:
1. Title must be unique across all posts
2. Slug must be unique across all posts (generated slugs checked for collisions)
3. Date must not be future-dated (prevents accidental publish of scheduled posts)
4. Tags must exist in `_data/tags.json` (prevent typos, ensure tag pages exist)
5. Featured image path must point to existing file (validated via file system check)
6. If `draft: true`, post excluded from `collections.posts` in production builds

---

### 2. Tag

**Representation**: JSON data file at `src/_data/tags.json`

**Purpose**: Represents a topic category for filtering and organizing posts

**Schema**:

```json
{
  "tags": [
    {
      "slug": "string",          // REQUIRED: URL-friendly identifier (lowercase, hyphens)
      "name": "string",          // REQUIRED: Display name (can include caps, spaces)
      "description": "string",   // OPTIONAL: Brief description of tag (for tag archive pages)
      "color": "string"          // OPTIONAL: Hex color for tag badge (e.g., "#007AFF")
    }
  ]
}
```

**Field Descriptions**:

| Field | Type | Required | Validation | Default |
|-------|------|----------|------------|---------|
| `slug` | string | Yes | Lowercase, hyphens only, no spaces, 2-30 chars | N/A |
| `name` | string | Yes | 2-30 chars, title case recommended | N/A |
| `description` | string | No | 50-200 chars | N/A |
| `color` | string | No | Hex color (#RRGGBB) or Tailwind color name | `#007AFF` (accent blue) |

**Example**:

```json
{
  "tags": [
    {
      "slug": "ai",
      "name": "Artificial Intelligence",
      "description": "Deep dives into machine learning, LLMs, and AI architecture patterns",
      "color": "#8B5CF6"
    },
    {
      "slug": "system-design",
      "name": "System Design",
      "description": "Scalable architecture, distributed systems, and infrastructure patterns",
      "color": "#10B981"
    },
    {
      "slug": "saleor",
      "name": "Saleor Commerce",
      "description": "Headless commerce platform, GraphQL APIs, and ecommerce integrations",
      "color": "#3B82F6"
    }
  ]
}
```

**Relationships**:
- **Tag → Blog Posts**: One-to-many (tag appears on multiple posts)

**Computed Fields** (generated at build time):
- `posts`: Array of all posts with this tag (sorted by date descending)
- `post_count`: Number of posts with this tag
- `url`: Tag archive page URL (e.g., `/tags/ai/`)

**Validation Rules**:
1. Slug must be unique across all tags
2. Name must be unique across all tags
3. Color must be valid hex code or Tailwind color (if provided)
4. Tags referenced in post frontmatter must exist in this file

---

### 3. Author Profile

**Representation**: JSON data file at `src/_data/author.json`

**Purpose**: Represents the blog author with biography, portrait, and social links

**Schema**:

```json
{
  "name": "string",               // REQUIRED: Author full name
  "short_bio": "string",          // REQUIRED: One-sentence bio (for homepage, post bylines)
  "long_bio": "string",           // REQUIRED: Full biography (for About page)
  "portrait": "string",           // REQUIRED: Path to author portrait image
  "portrait_alt": "string",       // REQUIRED: Alt text for portrait
  "role": "string",               // OPTIONAL: Professional role/title
  "location": "string",           // OPTIONAL: Location (city, country)
  "email": "string",              // OPTIONAL: Contact email
  "social": {                     // OPTIONAL: Social/professional links
    "github": "string",           // GitHub username or full URL
    "linkedin": "string",         // LinkedIn username or full URL
    "twitter": "string",          // Twitter/X username or full URL
    "website": "string"           // Personal website URL
  }
}
```

**Field Descriptions**:

| Field | Type | Required | Validation | Default |
|-------|------|----------|------------|---------|
| `name` | string | Yes | 2-50 chars | N/A |
| `short_bio` | string | Yes | 50-150 chars (one sentence) | N/A |
| `long_bio` | string | Yes | 200-1000 chars (multiple paragraphs OK) | N/A |
| `portrait` | string | Yes | Valid relative path in src/assets/images/ | N/A |
| `portrait_alt` | string | Yes | 10-100 chars | N/A |
| `role` | string | No | 5-50 chars | N/A |
| `location` | string | No | 5-50 chars | N/A |
| `email` | string | No | Valid email format | N/A |
| `social.github` | string | No | Username or full URL | N/A |
| `social.linkedin` | string | No | Username or full URL | N/A |
| `social.twitter` | string | No | Username or full URL | N/A |
| `social.website` | string | No | Valid URL | N/A |

**Example**:

```json
{
  "name": "Nabheet Madan",
  "short_bio": "Engineering leader building scalable systems at the intersection of AI, commerce, and developer tools.",
  "long_bio": "Nabheet is a full-stack engineer and technical architect with 10+ years experience building distributed systems, headless commerce platforms, and AI-powered applications. He specializes in system design, GraphQL APIs, and developer experience optimization. When not writing code, he's exploring new AI models, contributing to open-source, or sharing learnings through technical writing.",
  "portrait": "/assets/images/profile.jpg",
  "portrait_alt": "Portrait of Nabheet Madan in monochrome",
  "role": "Senior Engineering Leader",
  "location": "San Francisco, CA",
  "email": "hello@example.com",
  "social": {
    "github": "NabheetCloud",
    "linkedin": "nabheet",
    "twitter": "nabheet",
    "website": "https://example.com"
  }
}
```

**Relationships**:
- **Author → Blog Posts**: One-to-many (author writes multiple posts)

**Validation Rules**:
1. Name must match `author` field in all blog post frontmatter
2. Portrait path must point to existing image file
3. Email must be valid format (if provided)
4. Social URLs must be valid URLs (if provided)

---

### 4. Theme Preference

**Representation**: Browser localStorage (client-side)

**Purpose**: Persists user's light/dark theme choice across sessions

**Schema**:

```javascript
// localStorage key: 'theme'
{
  "theme": "light" | "dark" | "system"
}
```

**Field Descriptions**:

| Field | Type | Required | Validation | Default |
|-------|------|----------|------------|---------|
| `theme` | enum | Yes | One of: "light", "dark", "system" | "system" |

**Values**:
- `"light"`: Force light mode (ignore system preference)
- `"dark"`: Force dark mode (ignore system preference)
- `"system"`: Follow system preference (default on first visit)

**Behavior**:
1. **First Visit**: No localStorage value exists → read system preference via `window.matchMedia('(prefers-color-scheme: dark)')` → set theme accordingly → save to localStorage
2. **Subsequent Visits**: Read localStorage value → apply theme immediately (before page render to avoid flash)
3. **Toggle Click**: Read current theme → switch to opposite → save to localStorage → apply CSS class (`dark` or remove it)

**Implementation**:

```javascript
// Inline in <head> (blocking, but <1KB - prevents flash of wrong theme)
<script>
(function() {
  const stored = localStorage.getItem('theme');
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  
  if (stored === 'dark' || (!stored && prefersDark)) {
    document.documentElement.classList.add('dark');
  }
})();
</script>
```

**Validation Rules**:
1. Value must be one of: "light", "dark", "system"
2. If invalid or missing, fall back to "system"

---

## Relationships Diagram

```
┌─────────────┐
│  Author     │ (1)
│  Profile    │────────┐
└─────────────┘        │
                       │
                       │ writes
                       ↓
┌─────────────┐      (many)
│  Blog Post  │◄───────────────┐
└─────────────┘                │
       │                       │
       │ tagged with           │ appears on
       ↓ (many)                │
┌─────────────┐              (many)
│     Tag     │────────────────┘
└─────────────┘

┌─────────────┐
│   Theme     │ (client-side, no server relationship)
│ Preference  │
└─────────────┘
```

**Relationship Details**:
- **Author (1) → Blog Post (many)**: One author writes multiple posts. `author` field in post frontmatter must match `name` in `author.json`.
- **Blog Post (many) ↔ Tag (many)**: Many-to-many relationship. Post can have multiple tags, tag appears on multiple posts. `tags` array in post frontmatter references `slug` in `tags.json`.
- **Theme Preference**: Standalone client-side entity. No server relationship.

---

## Data Validation Strategy

### Build-Time Validation (Eleventy)

**Approach**: Validate all frontmatter and data files during Eleventy build. Fail fast on errors.

**Validation Points**:
1. **Frontmatter Schema**: Use custom Eleventy plugin or `eleventy-plugin-validate` to check required fields, types, and constraints
2. **Uniqueness**: Check for duplicate slugs, titles across all posts
3. **Referential Integrity**: Verify tags in post frontmatter exist in `tags.json`, author name matches `author.json`
4. **File Existence**: Confirm featured images, portrait images exist at specified paths
5. **Date Logic**: Ensure `updated >= date`, `date` is not future-dated (in production builds)

**Example Validation Plugin** (pseudocode):

```javascript
// .eleventy.js
eleventyConfig.addPlugin((eleventyConfig) => {
  eleventyConfig.on('eleventy.before', async ({ inputDir, outputDir }) => {
    // Load all posts
    const posts = eleventyConfig.getFilter('collections').posts;
    
    // Validate each post
    posts.forEach(post => {
      // Required fields
      if (!post.data.title) throw new Error(`Post missing title: ${post.inputPath}`);
      if (!post.data.date) throw new Error(`Post missing date: ${post.inputPath}`);
      if (!post.data.tags || !post.data.tags.length) throw new Error(`Post missing tags: ${post.inputPath}`);
      
      // Tag validation
      const validTags = eleventyConfig.globalData.tags.map(t => t.slug);
      post.data.tags.forEach(tag => {
        if (!validTags.includes(tag)) {
          throw new Error(`Invalid tag "${tag}" in post: ${post.inputPath}. Add to _data/tags.json first.`);
        }
      });
      
      // Unique slug validation
      const slugs = posts.map(p => p.data.slug);
      if (slugs.filter(s => s === post.data.slug).length > 1) {
        throw new Error(`Duplicate slug "${post.data.slug}" found. Slugs must be unique.`);
      }
    });
  });
});
```

### Runtime Validation (Client-Side)

**Approach**: Validate theme preference value in localStorage before applying.

**Validation**:

```javascript
const validThemes = ['light', 'dark', 'system'];
const stored = localStorage.getItem('theme');

if (stored && !validThemes.includes(stored)) {
  // Invalid value, reset to default
  localStorage.setItem('theme', 'system');
}
```

---

## State Management

### Server-Side (Build-Time) State

**Eleventy Collections**: Auto-generated collections from Markdown files.

```javascript
// Collections generated by Eleventy
{
  posts: [/* all posts sorted by date descending */],
  drafts: [/* posts with draft: true */],
  tagList: [/* unique tags across all posts */],
  postsByYear: {
    2025: [/* posts from 2025 */],
    2024: [/* posts from 2024 */]
  },
  postsByTag: {
    ai: [/* posts tagged "ai" */],
    "system-design": [/* posts tagged "system-design" */]
  }
}
```

**Filters & Computed Fields**:
- `reading_time`: Calculate from post word count
- `excerpt`: Extract from content if not in frontmatter
- `related_posts`: Find posts with overlapping tags
- `formatted_date`: Format date for display (e.g., "November 1, 2025")

### Client-Side State

**Theme Preference**: Managed via localStorage and `dark` class on `<html>` element.

```javascript
// State transitions
Initial: system (read from prefers-color-scheme)
User toggles: light ↔ dark (ignore system preference)
Page reload: read localStorage → apply theme
```

**No Other Client State**: Static blog has no dynamic state (no user authentication, no comments, no likes). All content pre-rendered at build time.

---

## Data Flow

### Content Creation Flow

```
1. Author writes Markdown post in src/posts/YYYY-MM-DD-slug.md
2. Author adds YAML frontmatter (title, date, tags, etc.)
3. Author commits to Git
4. Git push triggers CI/CD (GitHub Actions → Vercel/Netlify)
5. Eleventy build runs:
   a. Validate frontmatter (fail if errors)
   b. Parse Markdown to HTML
   c. Apply Prism.js syntax highlighting
   d. Generate collections (posts, tags, related posts)
   e. Render Nunjucks templates
   f. Output static HTML to dist/
6. Deploy dist/ to CDN
7. Readers access static HTML (no server processing)
```

### Theme Toggle Flow

```
1. Reader clicks theme toggle button (sun/moon icon)
2. JavaScript reads current theme from <html> class
3. Toggle: light → dark OR dark → light
4. Save new theme to localStorage
5. Add/remove 'dark' class on <html> element
6. CSS transitions apply (300ms ease-in-out)
7. Page reloads: inline script reads localStorage → applies theme before render
```

---

## Example File Structure

```
src/
├── _data/
│   ├── author.json              # Author profile (single author)
│   └── tags.json                # Tag definitions (array of tags)
│
├── posts/
│   ├── 2025-11-01-building-saleor-app.md
│   ├── 2025-11-03-understanding-cloudfront.md
│   └── 2025-11-05-ai-system-design.md
│
└── assets/
    └── images/
        ├── profile.jpg          # Author portrait
        └── posts/
            ├── saleor-architecture.jpg
            └── cloudfront-diagram.png
```

**Built Output** (`dist/` after Eleventy build):

```
dist/
├── index.html                   # Homepage (lists all posts)
├── about/index.html             # About page
├── posts/
│   ├── building-saleor-app/
│   │   └── index.html           # Individual post HTML
│   ├── understanding-cloudfront/
│   │   └── index.html
│   └── ai-system-design/
│       └── index.html
├── tags/
│   ├── ai/index.html            # Tag archive page (all AI posts)
│   ├── system-design/index.html
│   └── saleor/index.html
├── assets/
│   ├── styles/main.css          # Compiled Tailwind CSS
│   ├── js/bundle.js             # Minified JavaScript
│   └── images/                  # Optimized images
├── sitemap.xml                  # SEO sitemap
└── robots.txt                   # Crawler instructions
```

---

## Migration Strategy

**Initial Launch** (No Existing Content):
1. Create `src/_data/author.json` with author profile
2. Create `src/_data/tags.json` with initial tag definitions
3. Write 3-5 seed posts in `src/posts/` with frontmatter
4. Run Eleventy build to generate static site
5. Deploy to Vercel/Netlify

**Adding New Posts** (Ongoing):
1. Create new Markdown file in `src/posts/` following naming convention
2. Add frontmatter with required fields (title, date, author, tags)
3. Write Markdown content with code blocks, images, etc.
4. Commit and push to Git → triggers auto-deploy
5. Eleventy validates frontmatter, builds, deploys (5 minutes typical)

**Adding New Tags**:
1. Add tag definition to `src/_data/tags.json`
2. Reference tag slug in post frontmatter
3. Commit and push → Eleventy auto-generates tag archive page

**No Data Migration Needed**: Static site means no database migrations. Content is versioned in Git. Schema changes (new frontmatter fields) are backward-compatible (optional fields).

---

## Conclusion

This data model defines four entities (Blog Post, Tag, Author Profile, Theme Preference) with clear schemas, validation rules, and relationships. The static site architecture simplifies data management (no database), while build-time validation ensures data integrity. All entities are designed to scale to 100+ posts without code changes (content-driven architecture).

**Next Steps**:
- See [contracts/frontmatter-schema.json](./contracts/frontmatter-schema.json) for JSON Schema validation
- See [quickstart.md](./quickstart.md) for local development setup
- Run `/speckit.tasks` to generate implementation tasks from user stories

